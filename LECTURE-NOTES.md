# Основы алгоритмизации в языке программирования Python

### Встроенные и библиотечные функции для алгоритмов:

В Python есть встроенные функции и функции из популярных библиотек, которые предоставляют готовые реализации многих алгоритмов:

- Сортировка:
  - `sorted(iterable, key=None, reverse=False)`: Встроенная функция для сортировки любого итерируемого объекта (списка, кортежа, и т.д.). Возвращает новый отсортированный список, не мутируя его.

  ```Python
  my_list = [5, 2, 8, 1, 9]
  sorted_list = sorted(my_list) # [1, 2, 5, 8, 9]
  print(my_list) # [5, 2, 8, 1, 9]
  ```

  - `list.sort(key=None, reverse=False)`: Метод списка, который сортирует список на месте, мутируя его. Возвращает None.

  ```Python
  my_list = [5, 2, 8, 1, 9]
  my_list.sort() # [1, 2, 5, 8, 9]
  print(my_list) # [1, 2, 5, 8, 9]
  ```

  - `numpy.sort(a, axis=-1, kind=None, order=None)`: Функция из библиотеки NumPy для сортировки массивов NumPy, может быть очень эффективна для больших числовых массивов.

- Поиск элементов (самых малых и самых больших):
  - `heapq.nsmallest(n, iterable, key=None)` и `heapq.nlargest(n, iterable, key=None)`: Функции из модуля heapq для поиска n наименьших или наибольших элементов, используя алгоритм кучи (heap). Эффективны, если нужно найти только несколько элементов.

  ```Python
  import heapq
  my_list = [5, 2, 8, 1, 9, 4, 7]
  smallest_3 = heapq.nsmallest(3, my_list) # [1, 2, 4]
  largest_2 = heapq.nlargest(2, my_list) # [9, 8]
  ```

- Минимум / Максимум:
  - `min(iterable)` / `min(arg1, arg2, ...)`: Встроенная функция для поиска минимального элемента в итерируемом объекте или минимального из нескольких аргументов.
  - `max(iterable)` / `max(arg1, arg2, ...)`: Встроенная функция для поиска максимального элемента в итерируемом объекте или максимального из нескольких аргументов.

  ```Python
  my_list = [5, 2, 8, 1, 9]
  min_element = min(my_list) # 1
  max_element = max(my_list) # 9
  ```

- Факториал:
  - `math.factorial(x)`: Функция из модуля math для вычисления факториала.

  ```Python
  import math
  fact_5 = math.factorial(5) # 120
  ```

Сложность алгоритмов (Big O Notation): Измеряем эффективность

Когда мы говорим об алгоритмах, важно не только, как они работают, но и насколько эффективно они это делают. Для этого используется так называемая Big O notation (нотация "О" большое). Это математическая нотация, которая описывает, как время или память, необходимые для выполнения алгоритма, растут в зависимости от размера входных данных.

Основные идеи Big O:

•  Асимптотическая сложность: Big O фокусируется на том, как ведет себя алгоритм, когда размер входных данных (n) становится очень большим.
•  Порядок роста: Big O описывает скорость роста времени или памяти, а не точное время выполнения. Это позволяет сравнивать алгоритмы в общем, независимо от конкретной машины или языка.
•  Худший случай: Обычно Big O описывает сложность в худшем случае, так как это дает нам гарантию о максимальных ресурсах, которые может потратить алгоритм.

Распространенные типы Big O:

1. O(1) - Константная сложность:
  •  Время выполнения или потребление памяти не зависит от размера входных данных.
  •  Пример: Получение элемента по индексу в списке, добавление элемента в начало списка, проверка на четность числа.
  •  O(1) - это супер, так как алгоритм работает одинаково быстро независимо от количества входных данных

2. O(log n) - Логарифмическая сложность:
  •  Время выполнения растет пропорционально логарифму размера входных данных.
  •  Пример: Бинарный поиск (каждый шаг уменьшает область поиска вдвое).
  •  O(log n) очень эффективный алгоритм, если ваши данные отсортированы

3. O(n) - Линейная сложность:
  •  Время выполнения растет пропорционально размеру входных данных.
  •  Пример: Линейный поиск, проход по всем элементам списка.
  •  O(n) - это хороший показатель, ваш алгоритм не замедлится в 2 раза, если вы увеличите список в 2 раза

4. O(n log n) - Линейно-логарифмическая сложность:
  •  Время выполнения растет чуть быстрее, чем линейно.
  •  Пример: Быстрая сортировка, сортировка слиянием (в среднем случае).
  •  O(n log n) - очень хороший алгоритм для больших наборов данных

5. O(n^2) - Квадратичная сложность:
  •  Время выполнения растет пропорционально квадрату размера входных данных.
  •  Пример: Пузырьковая сортировка, сортировка вставками (в худшем случае).
  •  O(n^2) - старайтесь избегать этот тип сложности для больших наборов данных

6. O(2^n) - Экспоненциальная сложность:
  •  Время выполнения растет экспоненциально с размером входных данных.
  •  Пример: Некоторые алгоритмы поиска перебором всех вариантов.
  •  O(2^n) - крайне неэффективный алгоритм, следует избегать при любом раскладе

7. O(n!) - Факториальная сложность:
  •  Время выполнения растет факториально с размером входных данных.
  * Пример: Например, вычисление всех возможных перестановок в списке.
  •  O(n!) - такой алгоритм никогда не нужно использовать в "продакшене", он годится разве что для тестов

Анализ алгоритмов и сравнение:

Теперь мы можем проанализировать алгоритмы, которые мы рассматривали ранее:

•  Линейный поиск: O(n) – Проходим каждый элемент в худшем случае
•  Бинарный поиск: O(log n) – Каждый раз делим массив пополам
•  Поиск минимума/максимума: O(n) – проходим каждый элемент один раз
•  Факториал (итеративный): O(n) – цикл от 1 до n
•  Факториал (рекурсивный): O(n) – рекурсивный стек
•  Числа Фибоначчи (итеративный): O(n) – цикл от 1 до n
•  Числа Фибоначчи (рекурсивный): O(2^n) – экспоненциальная сложность (очень неэффективно)
•  Пузырьковая сортировка: O(n^2) – вложенные циклы
•  Быстрая сортировка (средний случай): O(n log n) – эффективное разбиение и сортировка
•  Быстрая сортировка (худший случай): O(n^2) – происходит при неудачном выборе опорного элемента

Примеры использования на практике:

•  Линейный поиск: Поиск конкретного товара в небольшом списке товаров
•  Бинарный поиск: Поиск значения в отсортированной базе данных
•  Быстрая сортировка: Сортировка списка пользователей по фамилии (или по другим параметрам)
•  Поиск минимума/максимума: Определение самой низкой и высокой температуры в наборе данных
•  Факториал: Комбинаторные задачи
•  Числа Фибоначчи: моделирование роста популяции

Пример с аннотацией типов:

Давай рассмотрим пример функции с аннотацией типов: